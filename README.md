# PAS: PostgreSQL Activity Statistics

A utility to extract activity statistics from a (local) postgres database cluster at high frequency for administration, profiling and troubleshooting purposes.

When started, PAS creates a connection (preferably local/socket) using a connectionpool in PAS with 1 connection, and uses prepared statements to query a limited number of catalog tables:

- pg_stat_activity
- pg_database
- pg_settings
- pg_stat_bgwriter
- pg_stat_database
- pg_stat_wal

The information is stored per (local) timestamp to allow understanding the database activities. To understand the activities, an (optional) webserver can be started to allow investigation of the gathered data.

By using the backend states and wait events in pg_stat_activity, it allows to understand the activity of database backends, as well as how the time was spent during these activities.

## Active session history by wait event type

To get an idea of the running efficiency of database queries, active session history grouped by event type can be used. By using the grouping per event type this is more an overview than a granular understanding:
![Active session history by wait event type](/images/active_session_history_by_wait_event_type.png)
(This is an example workload running generated by sysbench)

However, even using waits by wait event type, there already is a lot that can be seen:

- The rough approximate amount of concurrent activity is 85 concurrent sessions.
- The majority of the time spent is on cpu.

## Active session history by wait event

To get a more accurate understanding of exactly where time is spent, active session history grouped by the wait events itself can be used:
![Active session history by wait event](/images/active_session_history_by_wait_event.png)

This gives a much more detailed insight into where time is spent. This load spent the majority of its time on cpu, it can be seen that first event is wait event type 'client', wait event 'client read'.
This is useful for having an understanding of how the database cluster as a whole runs. But most of the time what is needed is to see if there are individual queries that perform significantly different from others.

## Active session history by Query ID

To see how much time was spent inside an actual query, the active session history information can be seen per Query ID:

![Active session history by query id](/images/active_session_history_by_queryid.png)

This makes the information about the time spent directly visible by Query ID. That provides a very granular insight into actual query performance. PAS however allows to zoom in further into the individual query.

## Active session history by Query

The Query ID is a link, and when clicked, such as for example Query ID -7870774297378276667, it allows to see the time spent over time, as well as the exact time spent for on CPU and each wait event:

![Active session history for a single query](/images/active_session_history_single_query.png)

This can show if this query was consistent over time. In this case it is visible this query was active on approximate 2 to 3 sessions at the same time, mostly on CPU, with some peaks, and a few peaks going beyond 20 concurrent sessions caused by the wait event type lwlock, wait event buffer content.

However, sometimes a single query id maps to multiple individual queries. This can happen when absolute values are used instead of bind variables, but this also is common for queries that either do not get a query id, or queries that do not have a query id yet, which all map to query id 0; see 'active session history by queryid' for the highest taker of time.
In such cases, clicking on queryid 0, PAS will show the individual queries:

![Active session history for a single queryid that maps to multiple queries](/images/active_session_history_single_queryid_multiple_sql.png)

This shows the different queries that all reported queryid 0. Because these cannot be identified uniquely by queryid, a (surrogate) number is shown which links the graphic showing the how much time was spent to the individual queries.

## IO Latency

A database is sensitive to IO latency, so IO latencies is something that is important to see.
![IO latency](/images/io_latencies.png)

## IO bandwidth

A database can produce a high amount of IO, and it's interesting to see where that IO comes from.
Another nice view here is to see what are the block write reasons: in postgres, a backend might need to write if the checkpointer and background writer cannot write enough buffers quickly enough.
![IO bandwidth](/images/io_bandwidth.png)

## Transaction ID age

An important concept of PostgreSQL is the transaction ID, for which it's a good thing to have an overview of the transaction and multi-transaction ID ages.
![Transaction ID age](/images/transaction_id_age.png)

# How to use PAS (PostgreSQL Activity Statistics)

PAS uses a sysmtemd unit file to store the configuration.

# PAS systemd unit file

A systemd unit file is the startup and shutdown script for systemd managed servers.

Do carefully inspect the unit file, and only proceed if you understand the settings.
The most prominent setting is the working directory (WorkingDirectory), which is where PAS will generate its archives.

# Database connection

PAS connects to a database, and therefore must be configured to be able to connect to the intended database.
By default PAS connects to the default postgres socket in /tmp, with the default port number 4321.

If you want to connect to a different socket location, or to a TCP address, set it using -c in the unit file.

Example:

```
pas -c "postgres://?host=127.0.0.1&port=1000&user=admin&dbname=mydatabase&sslrootcert=/postgres/ca.pem&sslkey=/postgres/tls_key.key&sslcert=/postgres/tls_cert.crt"
```

# Monitoring multiple postgres clusters

If you want to monitor more than one postgres cluster, create MULTIPLE unit files named "pas-mydatabase.service", each with their unique connection specified in the unit.
Also important is to have each of them use a DIFFERENT working directory, currently the archive names do not specify the source database from which the data originated.

# Installation

1. Copy the unit/service file to `/etc/systemd/system/`, optionally change the unit file name from `pas.service` to `pas-mydatabase.service`.
2. Reload systemd: `systemctlt daemon-reload` (this is safe and does not interrupt any processes).
3. Set the unit to be started at boot: `systemctl enable pas`. (if you want to only run pas at specific times, do not run "enable")
4. Start the unit: `systemctl start pas`.

# Warning!

PAS currently does not clean up it's archive files, so that is a task that has to be executed independently from PAS.
With lots of database usage, PAS archives can grow big. Please monitor carefully.

# Removal

1. Stop the service if running: `systemctl stop pas`.
2. Remove the unit: `systemctl disable pas`.
3. Remove the unit file: `rm /etc/systemd/system/pas.service`.
4. Reload systemd: `systemctl daemon-reload`.
